\subsection{Environments: Variable Binding Data-Structure}
\noindent
Though Y and Z combinators allow us to write recursive functions, this method quickly grows unwieldy as the complexity of our programs increases.
Things like variable bindings and jumping between scopes become difficult to manage. That's where environments come in:
\begin{Def}[Environment]

    \label{def:environment}

    \noindent
    An \textbf{environment} is a data-structure that keeps track of \textbf{variable bindings}, i.e., associations between variables and their corresponding values. Environments are written as finite mappings:
    \LARGE
    \[
        \{ x \mapsto v,\ y \mapsto w,\ z \mapsto f \}
    \]
    \normalsize
    Where each variable is mapped to a value. We may use such data-structure for state configurations. For example $\langle\{x\mapsto \lambda y.y\}, x  \rangle \downarrow v$. We shall denote environments as $\mathcal{E}$.
\end{Def}
\noindent

\begin{theo}[Substitution vs. Environment Model]

    When we care about the speed of our program, the substitution model quickly becomes inefficient.
    This is because we have to read our entire program to find free variables and handle additional logic.
    Though we track state in configurations, the program itself is \textbf{still functionally pure}.
\end{theo}

\newpage
\noindent
Here are the following operations we can preform on environments:
\begin{Def}[Operations on Environments]

   \label{def:env-operations}

   \noindent
   Environments support basic operations for managing variable bindings, similar to a map:

   \begin{itemize}
       \item \(\varnothing\) — represents the empty environment (OCaml: \texttt{empty}).
       \item $\langle\mathcal{E} \rangle$ — represents the current environment (OCaml: \texttt{env}).
       \item $\langle\mathcal{E}[x \mapsto v] \rangle$ — adds a new binding of variable \(x\) to value \(v\) (OCaml: \texttt{add x v env}).
       
       \item $\langle\mathcal{E}(x) \rangle$ — looks up the value of variable \(x\) (OCaml: \texttt{find\_opt x env}).
       
       \item $\langle\mathcal{E}(x) = \bot \rangle$ — indicates that \(x\) is unbound in the environment\\ (OCaml: \texttt{find\_opt x env = None}).
   \end{itemize}

   \noindent
   Additionally, if a new binding is added for a variable that already exists, the new binding \textbf{shadows} the old one:
   \[
   \mathcal{E}[x \mapsto v][x \mapsto w] = \mathcal{E}[x \mapsto w]
   \]
\end{Def}
\noindent
This next piece is text specific:
\begin{Def}[Extended Lambda Calculus]

Moving forward in the text, when we use \textbf{Lambda Calculus$^+$ (LC$^+$)}, we will be referring to the following grammar:

\begin{lstlisting}[numbers=none, mathescape=true,escapeinside={(*}{*)}]
    <expr> ::= <expr><expr>
            | let <var> = <expr> in <expr>
            | let rec <var> <var> = <expr> in <expr>
            | <val>
    <var> ::= [a-zA-Z]
    <val> ::= (*$\lambda$*)<var>.<expr> | <num>
    \end{lstlisting}


\noindent
We will continue to build on top of this or may momentarily add to it for example sake. For 
now we define such grammar to demonstrate properties of environments.
\end{Def}        

\newpage 

\noindent
Let's give \textbf{LC$^+$} some semantics:
\begin{Def}[LC$^+$ Semantics]

    \textbf{Values and variables}

\[
\begin{matrix}
% (E, λx.e) ⇓ (E, λx.e)
\begin{prooftree}
  \infer0{
    \langle\mathcal{E}, \lambda x.\,e\rangle \Downarrow \langle\mathcal{E}, \lambda x.\,e\rangle
  }
\end{prooftree}
&
% (E, x) ⇓ E(x)
\begin{prooftree}
    \hypo{\langle\mathcal{E}, x\rangle \neq \bot}
  \infer1{
    \langle\mathcal{E}, x\rangle \Downarrow \mathcal{E}(x)
  }
\end{prooftree}
&
% (E, n) ⇓ n
\begin{prooftree}
  \infer0{
    \langle\mathcal{E}, n\rangle \Downarrow n
  }
\end{prooftree}
&
\end{matrix}
\]
\noindent
\textbf{Application (unnamed closure)}

\[
\begin{prooftree}
  \hypo{\langle\mathcal{E}, e_{1}\rangle \Downarrow \langle\mathcal{E}', \lambda x.\,e\rangle}
  \hypo{\langle\mathcal{E}, e_{2}\rangle \Downarrow v_{2}}
  \hypo{\langle\mathcal{E}'[x \mapsto v_{2}],\, e\rangle \Downarrow v}
  \infer3{
    \langle\mathcal{E},\, e_{1}\,e_{2}\rangle \Downarrow v
  }
\end{prooftree}
\]

\noindent
\textbf{Application (named closure)}

\[
\begin{prooftree}
  \hypo{\langle\mathcal{E}, e_{1}\rangle \Downarrow (f,\;\mathcal{E}',\;\lambda x.\,e)}
  \hypo{\langle\mathcal{E}, e_{2}\rangle \Downarrow v_{2}}
  \hypo{\langle\mathcal{E}'[\,f \mapsto (\,f,\;\mathcal{E}',\;\lambda x.\,e)\,][x \mapsto v_{2}]\,e\rangle \Downarrow v}
  \infer3{
    \langle\mathcal{E},\, e_{1}\,e_{2}\rangle \Downarrow v
  }
\end{prooftree}
\]

\noindent
\textbf{Let expressions}

\[
\begin{matrix}
% let f = e1 in e2
\begin{prooftree}
  \hypo{\langle\mathcal{E}, e_{1}\rangle \Downarrow v_{1}}
  \hypo{\langle\mathcal{E}[\,x \mapsto v_{1}],\; e_{2}\rangle \Downarrow v_2}
  \infer2{
    \langle\mathcal{E},\; \text{let}\; x = e_{1}\; \text{in}\; e_{2}\rangle \Downarrow v_2
  }
\end{prooftree}
&
% let rec f x = e1 in e2
\begin{prooftree}
  \hypo{\langle\mathcal{E}[\,f \mapsto (\,f,\;\mathcal{E}',\;\lambda x.\,e_1)\,],\; e_{2}\rangle \Downarrow v_2}
  \infer1{
    \langle\mathcal{E},\; \text{let rec}\; f\,x = e_{1}\; \text{in}\; e_{2}\rangle \Downarrow v_2
  }
\end{prooftree}
\end{matrix}
\]

\end{Def}