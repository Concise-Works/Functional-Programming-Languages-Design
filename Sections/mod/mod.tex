\section{Modules In Ocaml}

This section details how OCaml deals with modular programming, including abstractions and interfaces.

\begin{Def}[Modular Programming]

Modular programming is a software design approach that emphasizes separating a program's functionality into independent, interchangeable modules,
which are composed of three key elements:

\begin{enumerate}
    \item \textbf{Namespaces:} A way of separating code into logical units of functions, types, and values together while avoiding name conflicts.
    
    \item \textbf{Abstraction/Encapsulation:} A way of abstracting away implementation details and organizing core functionality. This creates a clear boundary between the module's intent and its implementation for clarity.
    
    \item \textbf{Code Reuse:} Well-designed modules can serve as reusable components across multiple projects, reducing duplication.
\end{enumerate}

\end{Def}

\begin{Def}[The (\texttt{module}) \& (\texttt{struct}) Keyword in OCaml]

    The \textbf{module} keyword in OCaml is used to define a collection of related code elements (types, values, functions) that are grouped together into a single namespace.

    \begin{lstlisting}[language=OCaml, numbers=none, caption= \textbf{Basic Module Syntax:}]
    module ModuleName = struct
    (* Types, values, and functions *)
    type t = int * int
    let create x y = (x, y)
    let add (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)
    end
    \end{lstlisting}

    \noindent
    Where the \snippet{struct} keyword defines the collection of
    definitions under the module.
    Once defined, module elements are accessed using the dot notation:
    \begin{lstlisting}[language=OCaml, numbers=none]
    let point = ModuleName.create 10 20
    let sum = ModuleName.add point point
    \end{lstlisting}

    \noindent
    Multiple modules may be defined in a single file, and be used in and between other files.

\end{Def}

\newpage 

\begin{Def}[Module Access: (\texttt{open}) and Local Opens]
    OCaml provides multiple ways to access module contents:\\

    \noindent
    \textbf{Qualified access:} uses dot notation: \snippet{ModuleName.function\_name}\\
        
    \noindent
    \textbf{Global open:} brings all module contents into the current scope:
        \begin{lstlisting}[language=OCaml, numbers=none]
    (* All List functions now available without qualification *)
    open List  
    let x = map (fun x -> x * 2) [1; 2; 3]  (* No need for List.map *)
        \end{lstlisting}
        
    \noindent
    \textbf{Local open:} provides temporary access within a limited scope:
        \begin{lstlisting}[language=OCaml, numbers=none]
    (* Using Module.(expr) syntax *)
    let result = List.(
    map (fun x -> x * 2) [1; 2; 3]  
    (* List is open only in this scope *)
    )

    (* Outside the parentheses, module is not opened *)
    let standard = List.length [1; 2; 3]  (* Need qualification again *)
        \end{lstlisting}
 
\end{Def}

\begin{Def}[Module Signatures: (\texttt{sig}) \& (\texttt{module type})]
    
    Signatures are interfaces to modules:

    \begin{lstlisting}[language=OCaml, numbers=none]
    module type POINT = sig
      (* Abstract type - implementation hidden *)  
      type t              
      val private create : int -> int -> t
      val add : t -> t -> t
    end
    \end{lstlisting}

    \noindent
    The \snippet{val} keyword explains rather than defines like \snippet{let}. Signatures are then applied to modules to ensure they conform to the interface:
    
    \begin{lstlisting}[language=OCaml, numbers=none]
    module Point : POINT = struct
      type t = int * int
      let create x y = (x, y)
      let add (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)
      
      (* This function is private as its not in the signature *)
      let sub x y = x - y 
    end
    \end{lstlisting}
\end{Def}

\begin{Def}[Module Helper Pattern for Data Structures]
    
    A common pattern in OCaml is to create helper functions inside modules to simplify working with complex data structures. For example, with a binary tree:
    
    \begin{lstlisting}[language=OCaml, numbers=none]
    type 'a tree =
      | Leaf
      | Node of 'a * 'a tree * 'a tree

    module TreeExample = struct
      let l = Leaf
      let n l r = Node ((), l, r)
    end
    
    (* Using local open for concise tree construction *)
    let example = TreeExample.(n (n (n l l) l) (n l l))
    \end{lstlisting}
    
    \noindent
    This makes tree construction much more readable than the equivalent:
    \begin{lstlisting}[language=OCaml, numbers=none]
    let example = Node ((), Node ((), Node ((), Leaf, Leaf), Leaf), Node ((), Leaf, Leaf))
    \end{lstlisting}
\end{Def}


\begin{Def}[Modules and OCaml Projects]

  In OCaml, all \snippet{.ml} is implicitly wrapped in a module. Signatures are implicitly generated by the compiler without a corresponding \snippet{.mli} file.
  In such file, the signature body is defined.
\end{Def}

\vspace{-1em}
\begin{Example}[Module Example Project (Part 1)]

  Let's create a new project to demonstrate modules in OCaml. We'll create a simple module for basic shape math operations.
  \begin{lstlisting}[language=OCaml, numbers=none]
    dune init project demo 
    cd demo 
    vim lib/dune
\end{lstlisting}
We'll start by letting the project know of our modules:
\begin{lstlisting}[numbers=none]
   (library
     (name shapemath)          ; internal name
     (modules shape math)      ; modules that make up this library
   )
\end{lstlisting}
\end{Example}

\newpage 

\begin{Example}[Module Example Project (Part 2)]

  Next, we'll create the module files:
  \begin{lstlisting}[language=OCaml, numbers=none]
    vim lib/shape.mli 
  \end{lstlisting}

  \noindent
  Now we'll define the module interface:
  \begin{lstlisting}[language=OCaml, numbers=none]
    (* shape.mli *)
    type t
    val square : float -> t
    val area : t -> float
  \end{lstlisting}
  \noindent 
  Note, the \snippet{module type ... sig} absence. The interface is defined directly in the \snippet{.mli} file.\\

  \noindent
  Next, we'll define the implementation:
  \begin{lstlisting}[language=OCaml, numbers=none]
    vim lib/shape.ml
  \end{lstlisting}
  \begin{lstlisting}[language=OCaml, numbers=none]
    (* shape.ml *)
    type t = Square of float

    let square side = Square side

    let area = function
    | Square s -> s *. s
  \end{lstlisting}

  \noindent
  Now the math ml and mli files:
  \begin{lstlisting}[language=OCaml, numbers=none]
    (* math.mli *)
    val add : int -> int -> int
    val multiply : int -> int -> int
  \end{lstlisting}
  \begin{lstlisting}[language=OCaml, numbers=none]
    (* math.ml *)
    let add x y = x + y

    (*private function, as not defined in mli *)
    let add_zero x = (+) 0 x

    let multiply x y = add_zero (x * y)
  \end{lstlisting}
\end{Example}

\begin{Def}[Private Functions in Ocaml]

  If the \snippet{.ml} file defines a function not specified in the \snippet{.mli} file, it is considered private.
\end{Def}
\newpage 

\begin{Example}[Module Example Project (Part 3)]

  Setup access for \snippet{main} and \snippet{test}:

  \begin{lstlisting}[language=OCaml, numbers=none, caption={\textbf{bin/dune} file}]
    ;; bin/dune
    (executable
    (name main)            ; internal name for the executable
    (public_name demo)     ; how it appears installed or run via dune exec
    (modules main)         ; the main file is main.ml
    (libraries shapemath)  ; depends on our newly defined library
    )
  \end{lstlisting}
  \begin{lstlisting}[language=OCaml, numbers=none, caption={\textbf{bin/main.ml} file}]
    open Shapemath

    let () =
      (* Create a square with side length 5.0 *)
      let square = Shape.square 5.0 in

      (* Calculate and print the area of the square *)
      let area = Shape.area square in
      Printf.printf "Area of square with side 5.0: %f\n" area;

      (* Demonstrate the math module *)
      let sum = Math.add 10 20 in
      let product = Math.multiply 5 6 in
      Printf.printf "10 + 20 = %d\n" sum;
      Printf.printf "5 * 6 = %d\n" product;

      print_endline "Demo completed successfully!"
  \end{lstlisting}

  \noindent
  Now, we'll test the project:
  \begin{lstlisting}[language=OCaml, numbers=none]
    dune build
    dune exec bin/main.exe
  \end{lstlisting}

  \noindent
  Or even in utop:
  \begin{lstlisting}[language=OCaml, numbers=none]
    utop # Shapemath.Math.multiply 5 6;;
    - : int = 30

    utop # Shapemath.Math.add_zero 4 6;;
    Error: Unbound value Shapemath.Math.add_zero
  \end{lstlisting}
  \noindent
  We also see that our private function \snippet{add\_zero} is not accessible outside the module.
\end{Example}

\newpage 

\begin{Example}[Module Example Project (Part 4)]

  Finally, we'll add a test file to the project using OUnit2. 
  If for some reason OUnit2 is not installed, run in the terminal:
  \begin{lstlisting}[language=OCaml, numbers=none]
    opam install oUnit2
  \end{lstlisting}
  Now lets create the test file:
  
  \begin{lstlisting}[language=OCaml, numbers=none]
    vim test/test_demo.ml
  \end{lstlisting}
  \begin{lstlisting}[language=OCaml, numbers=none]
    open OUnit2
    open Shapemath

    let test_square _ =
      let square = Shape.square 5.0 in
      assert_equal 25.0 (Shape.area square)

    let test_add _ =
      assert_equal 30 (Math.add 10 20)

    let test_multiply _ =
      assert_equal 30 (Math.multiply 5 6)

    let suite =
      "suite">:::
      ["test_square">:: test_square;
      "test_add">:: test_add;
      "test_multiply">:: test_multiply]

    let () =
      run_test_tt_main suite
  \end{lstlisting}
  \noindent
  Now ensure the test is added to the \snippet{dune} file:
  \begin{lstlisting}[language=OCaml, numbers=none]
    (test
    (name test_demo)
    (libraries ounit2 shapemath))  
  \end{lstlisting}
  \noindent
  Now run the test in the terminal:
  \begin{lstlisting}[language=OCaml, numbers=none]
    dune runtest
  \end{lstlisting}
  \begin{lstlisting}[numbers=none]
    ...
    Ran: 3 tests in: 0.10 seconds.
    OK
  \end{lstlisting}
  \noindent
  As an exercise, try creating a test that will fail to see the error message.
  \end{Example}

  \newpage 

  \begin{Example}[Module Example Project Summary]

    In this example, we created a simple OCaml project with two modules: \texttt{shape} and \texttt{math}. We defined the modules in \texttt{lib/shape.ml} and \texttt{lib/math.ml}, and their interfaces in \texttt{lib/shape.mli} and \texttt{lib/math.mli}. We then created a \texttt{main} executable in \texttt{bin/main.ml} that used the modules. Finally, we created a test file in \texttt{test/test\_demo.ml} and ran the tests using \texttt{dune runtest}.\\

    \noindent
    This leaves us with the following project structure after \texttt{dune clean}:\\
    \dirtree{%
    .1 demo.
    .2 bin.
    .3 dune.
    .3 main.ml.
    .2 demo.opam.
    .2 dune-project.
    .2 lib.
    .3 dune.
    .3 math.ml.
    .3 math.mli.
    .3 shape.ml.
    .3 shape.mli.
    .2 test.
    .3 dune.
    .3 test\_demo.ml.
    }
  \end{Example}


